// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: queries.sql

package db

import (
	"context"
	"database/sql"
	"encoding/json"
)

const addGroupMember = `-- name: AddGroupMember :exec
INSERT INTO EmployeeOktaGroup (employee_id, okta_group_name)
VALUES ($1, $2)
ON CONFLICT (employee_id, okta_group_name) DO NOTHING
`

type AddGroupMemberParams struct {
	EmployeeID    string `json:"employee_id"`
	OktaGroupName string `json:"okta_group_name"`
}

func (q *Queries) AddGroupMember(ctx context.Context, arg AddGroupMemberParams) error {
	_, err := q.db.ExecContext(ctx, addGroupMember, arg.EmployeeID, arg.OktaGroupName)
	return err
}

const createEmployeeOktaGroup = `-- name: CreateEmployeeOktaGroup :exec
INSERT INTO EmployeeOktaGroup (employee_id, okta_group_name)
SELECT e.id, og.id
FROM Employee e,
     OktaGroup og
WHERE e.okta_id = $1
  AND og.name = $2
ON CONFLICT (employee_id, okta_group_name) DO NOTHING
`

type CreateEmployeeOktaGroupParams struct {
	OktaID string `json:"okta_id"`
	Name   string `json:"name"`
}

func (q *Queries) CreateEmployeeOktaGroup(ctx context.Context, arg CreateEmployeeOktaGroupParams) error {
	_, err := q.db.ExecContext(ctx, createEmployeeOktaGroup, arg.OktaID, arg.Name)
	return err
}

const createGroup = `-- name: CreateGroup :one
WITH inserted AS (
    INSERT INTO OktaGroup (name, okta_id)
        VALUES ($1, $2)
        ON CONFLICT (name) DO NOTHING
        RETURNING id, name, okta_id)
SELECT id, name, okta_id
FROM inserted
UNION
SELECT id, name, okta_id
FROM OktaGroup
WHERE name = $1
`

type CreateGroupParams struct {
	Name   string         `json:"name"`
	OktaID sql.NullString `json:"okta_id"`
}

type CreateGroupRow struct {
	ID     int32          `json:"id"`
	Name   string         `json:"name"`
	OktaID sql.NullString `json:"okta_id"`
}

func (q *Queries) CreateGroup(ctx context.Context, arg CreateGroupParams) (CreateGroupRow, error) {
	row := q.db.QueryRowContext(ctx, createGroup, arg.Name, arg.OktaID)
	var i CreateGroupRow
	err := row.Scan(&i.ID, &i.Name, &i.OktaID)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO Employee (name,
                      email,
                      okta_id)
VALUES ($1, $2, $3)
RETURNING id, name, email, okta_id, active
`

type CreateUserParams struct {
	Name   string `json:"name"`
	Email  string `json:"email"`
	OktaID string `json:"okta_id"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (Employee, error) {
	row := q.db.QueryRowContext(ctx, createUser, arg.Name, arg.Email, arg.OktaID)
	var i Employee
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.OktaID,
		&i.Active,
	)
	return i, err
}

const deactivateUser = `-- name: DeactivateUser :one
UPDATE Employee
SET active = false
WHERE okta_id = $1
RETURNING id, name, email, okta_id, active
`

func (q *Queries) DeactivateUser(ctx context.Context, oktaID string) (Employee, error) {
	row := q.db.QueryRowContext(ctx, deactivateUser, oktaID)
	var i Employee
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.OktaID,
		&i.Active,
	)
	return i, err
}

const deleteGroup = `-- name: DeleteGroup :exec
DELETE
FROM OktaGroup
WHERE okta_id = $1
`

func (q *Queries) DeleteGroup(ctx context.Context, oktaID sql.NullString) error {
	_, err := q.db.ExecContext(ctx, deleteGroup, oktaID)
	return err
}

const deleteGroupMembers = `-- name: DeleteGroupMembers :exec
DELETE
FROM EmployeeOktaGroup
WHERE okta_group_name IN (SELECT name
                          FROM OktaGroup
                          WHERE okta_id = $1)
`

func (q *Queries) DeleteGroupMembers(ctx context.Context, oktaID sql.NullString) error {
	_, err := q.db.ExecContext(ctx, deleteGroupMembers, oktaID)
	return err
}

const getGroupByID = `-- name: GetGroupByID :one
SELECT g.name                                                             AS group_name,
       g.okta_id                                                          AS group_okta_id,
       json_agg(json_build_object('OktaID', e.okta_id, 'Email', e.email)) AS members
FROM OktaGroup g
         LEFT JOIN EmployeeOktaGroup eog ON g.name = eog.okta_group_name
         LEFT JOIN Employee e ON e.okta_id = eog.employee_id
WHERE g.okta_id = $1
GROUP BY g.name, g.okta_id
`

type GetGroupByIDRow struct {
	GroupName   string          `json:"group_name"`
	GroupOktaID sql.NullString  `json:"group_okta_id"`
	Members     json.RawMessage `json:"members"`
}

func (q *Queries) GetGroupByID(ctx context.Context, oktaID sql.NullString) (GetGroupByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getGroupByID, oktaID)
	var i GetGroupByIDRow
	err := row.Scan(&i.GroupName, &i.GroupOktaID, &i.Members)
	return i, err
}

const getGroupByName = `-- name: GetGroupByName :one
SELECT g.name                                                             AS group_name,
       g.okta_id                                                          AS group_okta_id,
       json_agg(json_build_object('OktaID', e.okta_id, 'Email', e.email)) AS members
FROM OktaGroup g
         LEFT JOIN EmployeeOktaGroup eog ON g.name = eog.okta_group_name
         LEFT JOIN Employee e ON e.okta_id = eog.employee_id
WHERE g.name = $1
GROUP BY g.name, g.okta_id
`

type GetGroupByNameRow struct {
	GroupName   string          `json:"group_name"`
	GroupOktaID sql.NullString  `json:"group_okta_id"`
	Members     json.RawMessage `json:"members"`
}

func (q *Queries) GetGroupByName(ctx context.Context, name string) (GetGroupByNameRow, error) {
	row := q.db.QueryRowContext(ctx, getGroupByName, name)
	var i GetGroupByNameRow
	err := row.Scan(&i.GroupName, &i.GroupOktaID, &i.Members)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, name, email, okta_id, active
FROM Employee
WHERE email = $1
  AND active = $2
`

type GetUserByEmailParams struct {
	Email  string `json:"email"`
	Active bool   `json:"active"`
}

func (q *Queries) GetUserByEmail(ctx context.Context, arg GetUserByEmailParams) (Employee, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, arg.Email, arg.Active)
	var i Employee
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.OktaID,
		&i.Active,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, name, email, okta_id, active
FROM Employee
WHERE okta_id = $1
  AND active = true
`

func (q *Queries) GetUserByID(ctx context.Context, oktaID string) (Employee, error) {
	row := q.db.QueryRowContext(ctx, getUserByID, oktaID)
	var i Employee
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.OktaID,
		&i.Active,
	)
	return i, err
}

const listGroups = `-- name: ListGroups :many
SELECT g.name                                                             AS group_name,
       g.okta_id                                                          AS group_okta_id,
       json_agg(json_build_object('OktaID', e.okta_id, 'Email', e.email)) AS members
FROM OktaGroup g
         LEFT JOIN EmployeeOktaGroup eog ON g.name = eog.okta_group_name
         LEFT JOIN Employee e ON eog.employee_id = e.okta_id
GROUP BY g.name, g.okta_id
ORDER BY g.name
LIMIT $1 OFFSET $2
`

type ListGroupsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListGroupsRow struct {
	GroupName   string          `json:"group_name"`
	GroupOktaID sql.NullString  `json:"group_okta_id"`
	Members     json.RawMessage `json:"members"`
}

func (q *Queries) ListGroups(ctx context.Context, arg ListGroupsParams) ([]ListGroupsRow, error) {
	rows, err := q.db.QueryContext(ctx, listGroups, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListGroupsRow
	for rows.Next() {
		var i ListGroupsRow
		if err := rows.Scan(&i.GroupName, &i.GroupOktaID, &i.Members); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsers = `-- name: ListUsers :many
SELECT id, name, email, okta_id, active
FROM Employee
WHERE active = true
ORDER BY id
LIMIT $1 OFFSET $2
`

type ListUsersParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListUsers(ctx context.Context, arg ListUsersParams) ([]Employee, error) {
	rows, err := q.db.QueryContext(ctx, listUsers, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Employee
	for rows.Next() {
		var i Employee
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Email,
			&i.OktaID,
			&i.Active,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeAllGroupMembers = `-- name: RemoveAllGroupMembers :exec
DELETE
FROM EmployeeOktaGroup
WHERE okta_group_name = $1
`

func (q *Queries) RemoveAllGroupMembers(ctx context.Context, oktaGroupName string) error {
	_, err := q.db.ExecContext(ctx, removeAllGroupMembers, oktaGroupName)
	return err
}

const updateGroupName = `-- name: UpdateGroupName :one
UPDATE OktaGroup
SET name = $2
WHERE okta_id = $1
RETURNING id, name, okta_id
`

type UpdateGroupNameParams struct {
	OktaID sql.NullString `json:"okta_id"`
	Name   string         `json:"name"`
}

func (q *Queries) UpdateGroupName(ctx context.Context, arg UpdateGroupNameParams) (Oktagroup, error) {
	row := q.db.QueryRowContext(ctx, updateGroupName, arg.OktaID, arg.Name)
	var i Oktagroup
	err := row.Scan(&i.ID, &i.Name, &i.OktaID)
	return i, err
}

const updateGroupOktaID = `-- name: UpdateGroupOktaID :one
UPDATE OktaGroup
SET okta_id = $2
WHERE name = $1
RETURNING id, name, okta_id
`

type UpdateGroupOktaIDParams struct {
	Name   string         `json:"name"`
	OktaID sql.NullString `json:"okta_id"`
}

func (q *Queries) UpdateGroupOktaID(ctx context.Context, arg UpdateGroupOktaIDParams) (Oktagroup, error) {
	row := q.db.QueryRowContext(ctx, updateGroupOktaID, arg.Name, arg.OktaID)
	var i Oktagroup
	err := row.Scan(&i.ID, &i.Name, &i.OktaID)
	return i, err
}

const updateUser = `-- name: UpdateUser :one
UPDATE Employee
SET name   = $2,
    email  = $3,
    active = $4
WHERE okta_id = $1
RETURNING id, name, email, okta_id, active
`

type UpdateUserParams struct {
	OktaID string `json:"okta_id"`
	Name   string `json:"name"`
	Email  string `json:"email"`
	Active bool   `json:"active"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (Employee, error) {
	row := q.db.QueryRowContext(ctx, updateUser,
		arg.OktaID,
		arg.Name,
		arg.Email,
		arg.Active,
	)
	var i Employee
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.OktaID,
		&i.Active,
	)
	return i, err
}
